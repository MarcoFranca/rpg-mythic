// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // pooled (app)
  directUrl = env("DIRECT_URL") // direct (DDL/seed)
}

// — Eldoryon • Ficha perfeita (5e + Eldoryon), pronta para PostgreSQL/Supabase —

// /* ================================
// Enums
// ================================ */

enum CharacterState {
  DRAFT
  COMPLETE
  ARCHIVED
}

enum Visibility {
  PRIVATE
  CAMPAIGN
  PUBLIC
}

enum SkillRank {
  NONE
  TRAINED
  EXPERTISE
  HALF // "jack of all trades"
}

enum EquipSlot {
  MAIN_HAND
  OFF_HAND
  HEAD
  CHEST
  HANDS
  RING1
  RING2
  AMULET
  CAPE
  BOOTS
  BELT
}

// * ================================
// Catálogos (SRD + Eldoryon)
// ================================ */

model Ancestry {
  id        String   @id @db.VarChar(40) // ex: "drakhen", "elyriano"
  name      String
  shortLore String   @db.Text
  size      String   @default("medium") // pode virar enum se desejar
  speed     Int      @default(9) // fallback geral (m)
  bonuses   Json // { str:1, wis:1 } ou opções
  traits    Json // [{name,desc}]
  languages String[] // ["Comum","Elyriano"]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  characters Character[]

  @@index([name])
}

model Class {
  id              String     @id @db.VarChar(64) // agora aceita slugs maiores (ex: "arauto-de-elyra")
  name            String
  hitDie          String // "d6" | "d8" | "d10" | "d12"
  profs           Json // armor,weapons,tools,saves,skillsChoices,skillList
  featuresByLevel Json // <-- renomeado (antes era "features")
  spellData       Json? // progressão, foco, preparação
  subclasses      Subclass[]
  metaJson        Json // vitrine/preview/UI
  description     String
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([name])
}

model Subclass {
  id          String   @id @default(uuid())
  classId     String
  clazz       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  name        String
  slug        String   @unique
  description String
  metaJson    Json // vitrine (aliases, pros, cons, featuresPreview, tags)
  data        Json // <-- NOVO: dados ricos: grantedSpells, canalizarOptions, features por nível
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([classId])
}

model Background {
  id         String      @id @db.VarChar(40)
  name       String
  profs      Json // perícias, ferramentas, línguas extras
  equipment  Json? // itens iniciais
  traits     Json? // personalidade/ideais/laços/defeitos (textos)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  characters Character[]

  @@index([name])
}

model Spell {
  id        String   @id @db.VarChar(80)
  name      String
  level     Int
  school    String
  casting   Json // {components, time, duration, range}
  effect    Json // {scaling, save, damage, conditions}
  text      String? // descrição longa
  tags      String[]
  source    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([level, school])
  @@index([name])
}

// /* ================================
// Personagem (coração da ficha)
// ================================ */

model Character {
  id         String         @id @default(uuid())
  userId     String         @db.Uuid
  state      CharacterState @default(DRAFT)
  visibility Visibility     @default(PRIVATE)

  // Identidade
  name             String
  title            String?
  portraitUrl      String?
  pronoun          String? // "ele" | "ela" | "elu"
  ancestryId       String
  ancestry         Ancestry    @relation(fields: [ancestryId], references: [id])
  subAncestry      String? // linhagem/variante (livre)
  backgroundId     String?
  backgroundRef    Background? @relation(fields: [backgroundId], references: [id])
  spiritualBalance Json? // { value: number, trend: 'ASC' | 'DESC' | 'STABLE' }
  needsRecompute   Boolean?    @default(true)

  // Multiclasse (substitui classId/level únicos)
  // Ex.: [{classId:"guerreiro", level:3, subclassId:"campeao"}, {classId:"ladino", level:2}]
  classes Json

  level     Int     @default(1) // cache do total (soma de classes[]), útil para queries
  xp        Int     @default(0)
  alignment String? // opcional (ou "Eixo Espiritual" se preferir)

  inspiration Boolean @default(false)

  // Atributos (camadas)
  // attributes = { base:{str,dex,con,int,wis,cha}, bonuses:[{key,value,source}], temp:[...] }
  attributes       Json
  proficiencyBonus Int // cacheado por level; recompute via serviço

  // Combate & sentidos
  // hp = { max, current, temp, hit_dice:"1d10", death_saves:{s:0,f:0} }
  hp              Json
  // combat = { ac, initiative_bonus, speeds:{walk,fly,swim,climb,burrow}, resistances[], immunities[], vulnerabilities[] }
  combat          Json
  // senses = { darkvision?:m, blindsight?:m, tremorsense?:m, truesight?:m, passive:{perception, insight, investigation} }
  senses          Json
  exhaustionLevel Int   @default(0)
  rests           Json? // { lastShort?: Date, lastLong?: Date }

  // Ataques prontos para UI (derivado de armas/spells/features; opcionalmente persistido)
  // [{ source:"weapon|spell|feature", name, toHit, damage:"1d8+3", damageType, properties[] }]
  attacks Json?

  // Magia
  // spellcasting = { ability, cd, attack_bonus, slots:{1:{max,cur},...}, known:[], prepared:[], concentration?:{spellId,startedAt} }
  spellcasting Json?

  // Inventário & equipamento
  currency   Json // { cp, sp, gp, pp }
  // inventory = [{id,itemId?, name, qty, weight, rarity, tags[], effects[], attunementRequired, equippedSlot?:EquipSlot }]
  inventory  Json
  // attunement = { limit:3, attunedItemIds:[] }
  attunement Json
  mythicSets Json? // [{setId, pieces:[itemId], bonuses:{2pc:{...},...}}]

  // Proficiências & perícias
  // No 5e, detalhes ficam em class/background/ancestry; aqui mantemos em features/derivedSnapshot
  features   Json // [{name,desc,origin,level?,effects[]}]
  feats      Json? // [{id,name,desc,effects[]}]
  conditions Json? // [{key, level?, expiresAt?}]

  // Recursos de classe (Ki, Sorcery Points, etc.)
  // classResources = { ki:{current,max}, sorcery:{...}, superiority:{...}, custom:[{name,current,max,reset:"short|long"}] }
  classResources Json?

  // Companheiros & Formas (familiar, wild shape)
  companions Json? // [{type,name,refStatblockId?, customStatblock?}]
  forms      Json? // [{name, uses:{current,max}, options:[{statblockId|custom}], notes?}]

  // Núcleo Eldoryon
  // Cada um como recurso: { current, max, thresholds?[] } + detalhes próprios
  faith        Json // { current,max, thresholds:[...]}
  ether        Json // { current,max, resonance?:{ schools:string[], intensity:0..3 } }
  corruption   Json // { current,max, marks:[{name,desc}] }
  sigils       Int   @default(0)
  obelisks     Json? // [{obeliskId,status,keys[],progress}]
  idgAwareness Json? // { sensitivity:0..3, notes }

  // Relacionamentos de mundo
  factions Json? // [{id,name,rank,notes}]
  links    Json? // vínculos/NPCs: [{id,name,relation,notes}]
  quests   Json? // [{id,title,status,notes}]

  // Diário & meta
  journal  Json? // [{id, createdAt, markdown, tags[]}]
  metadata Json? // visuais/preferências
  xpLog    Json? // [{ value, reason, at }]

  // Cache de números prontos p/ UI
  // derivedSnapshot = { ac:{total,base,armor,shield,misc}, passives:{perception,insight,investigation}, encumbrance:{carried,capacity,status}, spell:{cd,attack}, ... }
  derivedSnapshot Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  revisions CharacterRevision[]

  @@index([userId])
  @@index([ancestryId])
  @@index([backgroundId])
  @@index([level])
}

// /* Auditoria/versionamento por evento (para “undo”, logs e histórico) */
model CharacterRevision {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  userId      String    @db.Uuid
  diff        Json
  createdAt   DateTime  @default(now())

  @@index([characterId, createdAt])
}

//armas e itens
enum Rarity {
  common
  uncommon
  rare
  very_rare
  legendary
  artifact
  mythic
}

enum Tier {
  low
  medium
  high
  legendary
  artifact
}

enum DamageType {
  slash
  pierce
  blunt
  fire
  cold
  acid
  poison
  necrotic
  radiant
  thunder
  lightning
  psychic
  force
  shadow
}

enum Range {
  melee
  short
  medium
  long
  extra_long
  infinite
}

enum ArmorType {
  light
  medium
  heavy
  shield
}

enum ArmorPart {
  helmet
  chestplate
  gloves
  bracers
  boots
  cloak
  shield_part
}

enum MemberRole {
  SPECTATOR
  PLAYER
  GM
}

enum AccountRole {
  SPECTATOR
  PLAYER
  GM
}

enum RoleTrack {
  PLAYER
  GM
}

enum RoleEventType {
  PROMOTE
  DEMOTE
  TRACK_SET
  ATTEMPT_DENIED
  SIGILS_ADJUST
}

enum ContentVisibility {
  global
  private
}

model Item {
  id            String   @id @default(uuid())
  name          String
  description   String
  rarity        Rarity
  tier          Tier
  value         Int
  levelRequired Int
  image         String? // URL (Supabase Storage)
  setCode       String?
  setName       String?
  setBonuses    Json? // [{pieces:number,effects:any[]}]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  Weapon     Weapon?
  Armor      Armor?
  Consumable Consumable?

  @@index([rarity])
  @@index([tier])
  @@index([setCode])
}

model Weapon {
  itemId              String      @id
  item                Item        @relation(fields: [itemId], references: [id], onDelete: Cascade)
  category            String
  subCategory         String?
  weight              Float
  primaryDamage       Json
  secondaryDamage     Json?
  damageType          DamageType
  secondaryDamageType DamageType?
  range               Range
  specialRange        String?
  properties          Json // Json array
  elementalType       String?
  requirements        Json
  abilitiesActive     Json
  abilitiesPassive    Json
  attributeBoosts     Json?
  rarityBoosts        Json?
  disadvantages       Json?
  durability          Int
  classRestrictions   Json?
  ongoingEffects      Json?
  targetEffects       Json?
  conditionalEffects  Json?
  grantedResistances  Json?

  @@index([damageType])
}

model Armor {
  itemId             String    @id
  item               Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  armorPart          ArmorPart
  armorType          ArmorType
  subType            String?
  defenseValue       Int
  maxDexBonus        Int?
  resistances        Json
  vulnerabilities    Json?
  penalties          Json
  disadvantages      Json?
  requirements       Json
  abilities          Json
  ongoingEffects     Json?
  conditionalEffects Json?
  attributeBoosts    Json?
  grantedResistances Json?
  durability         Int
  classRestrictions  Json?

  @@index([armorType])
  @@index([armorPart])
}

model Consumable {
  itemId          String    @id
  item            Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  consumableType  String // default: "potion"
  effectType      String // default: "heal" etc.
  effectIntensity Json
  effectDuration  String
  usageConditions Json?
  quantity        Int
  expiration      DateTime?
}

// + modelos de mesa, vínculo e sessão
model GameTable {
  id          String   @id @default(uuid())
  title       String
  description String?
  status      String   @default("draft")
  visibility  String   @default("public")
  ruleset     Json?
  createdById String?
  createdBy   User?    @relation(fields: [createdById], references: [id], onDelete: SetNull)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  memberships Membership[]
  sessions    Session[]

  @@index([status])
  @@index([visibility])
  @@index([createdById])
  @@map("Table") // mantém a tabela física "Table"
}

model User {
  id          String      @id @default(uuid())
  supabaseId  String      @unique
  email       String      @unique
  displayName String?     @unique
  image       String?
  accountRole AccountRole @default(SPECTATOR)
  track       RoleTrack? // trilha fixa (nula até o 1º upgrade)

  // Economia / Progressão
  sigils      Int         @default(0)
  playerSlots Int         @default(2)
  stats       Json?
  profile     Json?
  roleEvents  RoleEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  memberships        Membership[]
  monsters           Monster[]           @relation("UserMonsters")
  tablesCreated      GameTable[] // 👈 backref de GameTable.createdBy
  walletTransactions WalletTransaction[] // <— backref de WalletTransaction.user
}

model Membership {
  id       String     @id @default(uuid())
  userId   String
  tableId  String
  role     MemberRole @default(SPECTATOR)
  notes    String?
  joinedAt DateTime   @default(now())

  user  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  table GameTable @relation(fields: [tableId], references: [id]) // <- GameTable

  @@unique([userId, tableId])
  @@index([tableId])
  @@index([userId])
}

// Conteúdo do GM (mínimo agora; evoluímos depois)
model Monster {
  id          String  @id @default(uuid())
  name        String
  description String?
  // blocos mínimos de combate (vamos expandir depois conforme seu domínio)
  meta        Json? // AC/HP/speed/atributos/traits/ações/resistências

  visibility  ContentVisibility @default(private)
  ownerUserId String
  owner       User              @relation("UserMonsters", fields: [ownerUserId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // vínculo opcional à campanha (quando “permitido” pelo GM)
  allowedTables Json? // ex: ["tableId1","tableId2"] (podemos normalizar depois)

  @@index([ownerUserId])
  @@index([visibility])
}

model Session {
  id        String    @id @default(uuid())
  tableId   String
  title     String
  startsAt  DateTime
  endsAt    DateTime?
  agenda    Json?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  table GameTable @relation(fields: [tableId], references: [id]) // <- GameTable

  @@index([tableId])
}

model WalletTransaction {
  id        String   @id @default(uuid())
  userId    String
  delta     Int // +ganhos / -gastos
  reason    String // ex: "campaign_entry", "item_purchase"
  meta      Json?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model RoleEvent {
  id          String        @id @default(cuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        RoleEventType
  from        AccountRole?
  to          AccountRole?
  track       RoleTrack?
  deltaSigils Int? // p/ SIGILS_ADJUST ou contexto
  reason      String? // msg livre
  createdAt   DateTime      @default(now())

  @@index([userId, createdAt])
}
