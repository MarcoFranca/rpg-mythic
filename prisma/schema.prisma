generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")   // pooled (app)
  directUrl = env("DIRECT_URL")     // direct (DDL/seed)
}

enum Rarity {
  common
  uncommon
  rare
  very_rare
  legendary
  artifact
  mythic
}

enum Tier {
  low
  medium
  high
  legendary
  artifact
}

enum DamageType {
  slash
  pierce
  blunt
  fire
  cold
  acid
  poison
  necrotic
  radiant
  thunder
  lightning
  psychic
  force
  shadow
}

enum Range {
  melee
  short
  medium
  long
  extra_long
  infinite
}

enum ArmorType {
  light
  medium
  heavy
  shield
}

enum ArmorPart {
  helmet
  chestplate
  gloves
  bracers
  boots
  cloak
  shield_part
}

enum MemberRole {
  OBSERVER
  PLAYER
  GM
}

model Item {
  id             String   @id @default(uuid())
  name           String
  description    String
  rarity         Rarity
  tier           Tier
  value          Int
  levelRequired  Int
  image          String?  // URL (Supabase Storage)
  setCode        String?
  setName        String?
  setBonuses     Json?    // [{pieces:number,effects:any[]}]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  Weapon     Weapon?
  Armor      Armor?
  Consumable Consumable?

  @@index([rarity])
  @@index([tier])
  @@index([setCode])
}

model Weapon {
  itemId               String  @id
  item                 Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  category             String
  subCategory          String?
  weight               Float
  primaryDamage        Json
  secondaryDamage      Json?
  damageType           DamageType
  secondaryDamageType  DamageType?
  range                Range
  specialRange         String?
  properties           Json    // Json array
  elementalType        String?
  requirements         Json
  abilitiesActive      Json
  abilitiesPassive     Json
  attributeBoosts      Json?
  rarityBoosts         Json?
  disadvantages        Json?
  durability           Int
  classRestrictions    Json?
  ongoingEffects       Json?
  targetEffects        Json?
  conditionalEffects   Json?
  grantedResistances   Json?

  @@index([damageType])
}

model Armor {
  itemId              String   @id
  item                Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)
  armorPart           ArmorPart
  armorType           ArmorType
  subType             String?
  defenseValue        Int
  maxDexBonus         Int?
  resistances         Json
  vulnerabilities     Json?
  penalties           Json
  disadvantages       Json?
  requirements        Json
  abilities           Json
  ongoingEffects      Json?
  conditionalEffects  Json?
  attributeBoosts     Json?
  grantedResistances  Json?
  durability          Int
  classRestrictions   Json?

  @@index([armorType])
  @@index([armorPart])
}

model Consumable {
  itemId           String  @id
  item             Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  consumableType   String  // default: "potion"
  effectType       String  // default: "heal" etc.
  effectIntensity  Json
  effectDuration   String
  usageConditions  Json?
  quantity         Int
  expiration       DateTime?
}

// + modelos de mesa, vínculo e sessão
model Table {
  id          String       @id @default(uuid())
  title       String
  description String?
  status      String       @default("draft")     // draft|active|archived
  visibility  String       @default("public")    // public|unlisted|private
  ruleset     Json?
  createdById String?                              // relacione com User depois se quiser
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  memberships Membership[]
  sessions    Session[]

  @@index([status])
  @@index([visibility])
}

model Membership {
  id       String     @id @default(uuid())
  userId   String
  tableId  String
  role     MemberRole @default(OBSERVER)
  notes    String?
  joinedAt DateTime   @default(now())

  table Table @relation(fields: [tableId], references: [id])

  @@unique([userId, tableId])
  @@index([tableId])
  @@index([userId])
}

model Session {
  id        String   @id @default(uuid())
  tableId   String
  title     String
  startsAt  DateTime
  endsAt    DateTime?
  agenda    Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  table Table @relation(fields: [tableId], references: [id])

  @@index([tableId])
}