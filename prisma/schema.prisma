generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // pooled (app)
  directUrl = env("DIRECT_URL") // direct (DDL/seed)
}

enum Rarity {
  common
  uncommon
  rare
  very_rare
  legendary
  artifact
  mythic
}

enum Tier {
  low
  medium
  high
  legendary
  artifact
}

enum DamageType {
  slash
  pierce
  blunt
  fire
  cold
  acid
  poison
  necrotic
  radiant
  thunder
  lightning
  psychic
  force
  shadow
}

enum Range {
  melee
  short
  medium
  long
  extra_long
  infinite
}

enum ArmorType {
  light
  medium
  heavy
  shield
}

enum ArmorPart {
  helmet
  chestplate
  gloves
  bracers
  boots
  cloak
  shield_part
}

enum MemberRole {
  SPECTATOR
  PLAYER
  GM
}

enum AccountRole {
  SPECTATOR
  PLAYER
  GM
}

enum ContentVisibility {
  global
  private
}

model Item {
  id            String   @id @default(uuid())
  name          String
  description   String
  rarity        Rarity
  tier          Tier
  value         Int
  levelRequired Int
  image         String? // URL (Supabase Storage)
  setCode       String?
  setName       String?
  setBonuses    Json? // [{pieces:number,effects:any[]}]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  Weapon     Weapon?
  Armor      Armor?
  Consumable Consumable?

  @@index([rarity])
  @@index([tier])
  @@index([setCode])
}

model Weapon {
  itemId              String      @id
  item                Item        @relation(fields: [itemId], references: [id], onDelete: Cascade)
  category            String
  subCategory         String?
  weight              Float
  primaryDamage       Json
  secondaryDamage     Json?
  damageType          DamageType
  secondaryDamageType DamageType?
  range               Range
  specialRange        String?
  properties          Json // Json array
  elementalType       String?
  requirements        Json
  abilitiesActive     Json
  abilitiesPassive    Json
  attributeBoosts     Json?
  rarityBoosts        Json?
  disadvantages       Json?
  durability          Int
  classRestrictions   Json?
  ongoingEffects      Json?
  targetEffects       Json?
  conditionalEffects  Json?
  grantedResistances  Json?

  @@index([damageType])
}

model Armor {
  itemId             String    @id
  item               Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  armorPart          ArmorPart
  armorType          ArmorType
  subType            String?
  defenseValue       Int
  maxDexBonus        Int?
  resistances        Json
  vulnerabilities    Json?
  penalties          Json
  disadvantages      Json?
  requirements       Json
  abilities          Json
  ongoingEffects     Json?
  conditionalEffects Json?
  attributeBoosts    Json?
  grantedResistances Json?
  durability         Int
  classRestrictions  Json?

  @@index([armorType])
  @@index([armorPart])
}

model Consumable {
  itemId          String    @id
  item            Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  consumableType  String // default: "potion"
  effectType      String // default: "heal" etc.
  effectIntensity Json
  effectDuration  String
  usageConditions Json?
  quantity        Int
  expiration      DateTime?
}

// + modelos de mesa, v√≠nculo e sess√£o
model GameTable {
  id          String   @id @default(uuid())
  title       String
  description String?
  status      String   @default("draft")
  visibility  String   @default("public")
  ruleset     Json?
  createdById String?
  createdBy   User?    @relation(fields: [createdById], references: [id], onDelete: SetNull)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  memberships Membership[]
  sessions    Session[]

  @@index([status])
  @@index([visibility])
  @@index([createdById])
  @@map("Table") // mant√©m a tabela f√≠sica "Table"
}

model User {
  id          String      @id @default(uuid())
  supabaseId  String      @unique
  email       String      @unique
  displayName String?
  image       String?
  accountRole AccountRole @default(SPECTATOR)

  // Economia / Progress√£o
  sigils      Int   @default(0)
  playerSlots Int   @default(2)
  stats       Json?
  profile     Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Rela√ß√µes
  memberships        Membership[]
  monsters           Monster[]           @relation("UserMonsters")
  tablesCreated      GameTable[]         // üëà backref de GameTable.createdBy
  walletTransactions WalletTransaction[] // <‚Äî backref de WalletTransaction.user
}

model Membership {
  id       String     @id @default(uuid())
  userId   String
  tableId  String
  role     MemberRole @default(SPECTATOR)
  notes    String?
  joinedAt DateTime   @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  table     GameTable @relation(fields: [tableId], references: [id])   // <- GameTable

  @@unique([userId, tableId])
  @@index([tableId])
  @@index([userId])
}

// Conte√∫do do GM (m√≠nimo agora; evolu√≠mos depois)
model Monster {
  id          String  @id @default(uuid())
  name        String
  description String?
  // blocos m√≠nimos de combate (vamos expandir depois conforme seu dom√≠nio)
  meta        Json? // AC/HP/speed/atributos/traits/a√ß√µes/resist√™ncias

  visibility  ContentVisibility @default(private)
  ownerUserId String
  owner       User              @relation("UserMonsters", fields: [ownerUserId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // v√≠nculo opcional √† campanha (quando ‚Äúpermitido‚Äù pelo GM)
  allowedTables Json? // ex: ["tableId1","tableId2"] (podemos normalizar depois)

  @@index([ownerUserId])
  @@index([visibility])
}

model Session {
  id        String   @id @default(uuid())
  tableId   String
  title     String
  startsAt  DateTime
  endsAt    DateTime?
  agenda    Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  table     GameTable @relation(fields: [tableId], references: [id])   // <- GameTable

  @@index([tableId])
}

model WalletTransaction {
  id        String   @id @default(uuid())
  userId    String
  delta     Int // +ganhos / -gastos
  reason    String // ex: "campaign_entry", "item_purchase"
  meta      Json?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}
